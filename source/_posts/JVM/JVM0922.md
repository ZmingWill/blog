---
title: 浅析JVM原理
date: 2020/9/12 15:31:32
layout: Java0912
permalink:  Java0912.html
cover:

---
在这几天接触到新项目，实现业务时，参数传递早已是见多不怪了，但说起它其中的原理，便是一脸问号了，那么到底参数传递是怎么实现的呢？那就由我一步步去揭露真相吧！
<!--more-->

#### 一、JVM体系结构：
- 类装载器ClassLoader: 用来装载.class文件

- 执行引擎: 执行字节码，或者执行本地方法

- 运行时数据区:方法区、堆、Java栈、程序计数器、本地方法栈

虚拟机的类加载机制：JVM把描述类数据的字节码.Class文件加载到内存，并对数据进行效验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。



#### 二、JVM原理分析：

JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一天指令翻译成不同平台机器码，通过特定平台运行。


#### 三、JVM执行程序的过程：

1. 加载.class文件
2. 管理并分配内存
3. 执行垃圾收集

四步完成JVM环境：

1. 创建JVM装载环境和配置

2. 装载JVM.dll

3. 初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例

4. 调用JNIEnv实例装载并处理class类。

#### 四、JVM的生命周期
JVM实例和JVM执行引擎实例：
(1). JVM实例对应了一个独立运行的java程序————进程级别
* 一个运行时的Java虚拟机(JVM)负责运行一个Java程序。
* 当启动一个Java程序时，一个Java虚拟机实例随之诞生，当程序关闭退出这个虚拟机也随之消亡。
* 当运行多个Java程序时，Java虚拟机也会随之实例多个，每个Java程序都运行于各自的Java虚拟机实例中。

（2）JVM执行引擎实例则对应了属于运行程序的线程——线程级别

JVM的生命周期：
(1) JVM实例的诞生
* 当启动一个Java程序时，一个JVM实例便产生了，任何一个拥有public static void main(String[]args)函数的class都可以作为JVM实例运行的起点。

(2) JVM实例的运行
* main作为该程序初始线程的起点，任何其他线程都由该线程
启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。


(3) JVM实例的消：

当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。

#### 五、类装载器：
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称链接。

##### （一）、加载
加载阶段是“类加载机制”中的一个阶段，这个阶段通常也被称作"装载"：
1. 通过“类全名”来获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构装换为方法区的运行数据结构
3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些对象的访问路口

相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。

##### （二）、验证：
验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。
验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。

##### （三）、准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:

public static int value  = 12;

那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。

上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：

public static final int value = 123;

编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123。

##### （四）、解析
